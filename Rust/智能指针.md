## Box
Box 是指向堆上数据的自有指针。

`Box<T>` 会实现 `Deref<Target = T>`，这意味着可以直接在 `Box<T>` 上通过 `T` 调用相应方法。


```rust
fn main() {
    let five = Box::new(5);
    println!("five: {}", *five);
}
```

![](../images/google.github.io_comprehensive-rust_zh-CN_smart-pointers_box.html.png)

Box 类似于 C++中的 `std::unique_ptr`，只是它保证不为 null

- 在以下情况下，`Box` 可能会很实用：
    - 在编译时间遇到无法知晓大小的类型，但 Rust 编译器需要知道确切大小。
    - 想要转让大量数据的所有权。为避免在堆栈上复制大量数据，请改为将数据存储在 `Box` 中的堆上，以便仅移动指针。

在创建 `Box<Point>` 实例的时候会发生所有权转移：资源从栈上 move 到了堆上，原来栈上的那片资源被置为无效状态。

```rust
struct Point {
    x: u32,
    y: u32
}

fn foo() -> Box<Point> {
    let p = Point {x: 10, y: 20};    
    let boxed = Box::new(p);  // 创建Box实例
    let q = p;                // 这一句用来检查p有没有被move走
    boxed
}
fn main() {
    let _p = foo();
}
```
Point 类型本身就是 move 语义的，所以会发生所有权这样的转移。如果是基本类型，具有 copy 语意，就不会发生所有权转移。

使用解引用符号 `*`，把里面的堆上的值再次移动回栈上：
```rust
let boxed: Box<u8> = Box::new(5);
let val: u8 = *boxed;    // 这里这个val整数实例就是在栈上的值
```
对于具有 copy 语义的类型来说，解引用回来后，Box 还能使用。对于具有 move 语义的类型来说，会发生所有权的转移。
## Rc
`Rc` 是引用计数的共享指针。

```rust
use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&a);

    println!("a: {a}");
    println!("b: {b}");
}
```