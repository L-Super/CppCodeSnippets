我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。

所以一般更喜欢使用纹理 (Texture)。纹理是一个2D 图片（甚至也有1D 和3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。

> 除了图像以外，纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上。

为了能够把纹理映射 (Map)到三角形上，我们需要指定三角形的每个顶点分别对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标 (Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值 (Fragment Interpolation)。

纹理坐标在 x 和 y 轴上，范围为0到1之间（注意我们使用的是2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样 (Sampling)。纹理坐标起始于 (0, 0)，也就是纹理图片的左下角，终止于 (1, 1)，即纹理图片的右上角。

下图展示了我们是如何把纹理坐标映射到三角形上的。

![](https://learnopengl-cn.github.io/img/01/06/tex_coords.png)

我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为 (0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为 (0.5, 1.0)；同理右下方的顶点设置为 (1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。

纹理坐标看起来就像这样：

```c++
float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};
```

对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉 OpenGL 该怎样对纹理**采样**。

## 纹理环绕方式

纹理坐标的范围通常是从 (0, 0)到 (1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL 默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但 OpenGL 提供了更多的选择：

|环绕方式|描述|
|---|---|
|GL_REPEAT|对纹理的默认行为。重复纹理图像。|
|GL_MIRRORED_REPEAT|和GL_REPEAT一样，但每次重复图片是镜像放置的。|
|GL_CLAMP_TO_EDGE|纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。|
|GL_CLAMP_TO_BORDER|超出的坐标为用户指定的边缘颜色。|

当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：

![](https://learnopengl-cn.github.io/img/01/06/texture_wrapping.png)

前面提到的每个选项都可以使用 `glTexParameter()`函数对单独的一个坐标轴设置（`s`、`t`（如果是使用3D 纹理那么还有一个 `r`）它们和 `x`、`y`、`z` 是等价的）：

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

第一个参数指定了纹理目标；我们使用的是2D 纹理，因此纹理目标是 GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是 `WRAP` 选项，并且指定 `S` 和 `T` 轴。最后一个参数需要我们传递一个环绕方式 (Wrapping)，在这个例子中 OpenGL 会给当前激活的纹理设定纹理环绕方式为 `GL_MIRRORED_REPEAT`。

如果我们选择 GL_CLAMP_TO_BORDER 选项，我们还需要指定一个边缘的颜色。这需要使用 `glTexParameter()` 函数的 `fv` 后缀形式，用 `GL_TEXTURE_BORDER_COLOR` 作为它的选项，并且传递一个 float 数组作为边缘的颜色值：

```c++
float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
```

