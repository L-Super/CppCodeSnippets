# 静态动态库概述
静态库（.lib）

函数和数据被编译进一个二进制文件（通常扩展名为.LIB）。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件（.EXE文件）。当发布产品时，只需要发布这个可执行文件，并不需要发布被使用的静态库。

动态库（.lib文件和.dll文件）

在使用动态库的时候，编译后往往提供两个文件：一个引入库（.lib）文件（也称“导入库文件”）和一个DLL（.dll）文件。如果只提供一个DLL文件，使用显示连接的方式也可以调用，只是稍加麻烦而已。当EXE程序确实要调用这些DLL模块的情况下，系统才会将它们装载到内存空间中。发布产品时，还需要发布该程序要调用的动态链接库。
 
 ## 区别
 虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质的区别。对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。
 
 在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。
 
 ## 引入库lib和静态库Lib的区别

引入库和静态库（.lib）的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于引入库而言，其实际的执行代码位于动态库中，引入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。但是引入库文件的引入方式和静态库一样，要在链接路径上添加找到这些.lib的路径。
 
 # 静态库lib和动态dll的使用
## 动态dll的使用

动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件。或者只提供dll文件。Dll的调用有显式连接和隐式连接两种：隐式连接需要三个东西，分别是*.h头文件，lib库（动态的），DLL库；显式连接只需要.dll文件即可。

### 隐式连接  
隐式链接需要三个东西，分别是*.h头文件，lib库（动态的），DLL库，而这里的lib库仅是编译的时候用，运行时候不用，运行时只用dll

#### 添加lib
**前提，三种方法均需要添加头文件**

在调用DLL中导出的函数之前要include对应的头文件，可以拷贝到工程调用源文件的同一目录下，也可以通过VS添加（include）头文件目录，VS中配置方法：
`VS项目->属性->配置属性->C/C++->常规->附加包含目录`

方法1:
通过设置工程配置来添加lib库.

1. 添加工程的头文件目录：工程->属性->配置属性->c/c++->常规->附加包含目录：加上头文件存放目录。
2. 添加文件引用的lib静态库路径：工程->属性->配置属性->链接器->常规->附加库目录：加上lib文件存放目录。  
3. 然后添加工程引用的lib文件名：工程->属性->配置属性->链接器->输入->附加依赖项：加上lib文件名。

这种方法比较繁琐,且不直观,而且还可能要争对debug版本和release版本作不同的配置,因为我们生成的两个版本的库可能放在不同的目录中的.

方法2: 
同样先添加头文件，再使用编译语句添加lib

```C++
#ifdef _DEBUG
#pragma comment(lib,"..\\debug\\LedCtrlBoard.lib")
#else
#pragma comment(lib,"..\\release\\LedCtrlBoard.lib")
#endif
```
  
  [[pragma#pragma comment]]

这种方法直观,方便,且可以按如上直接区分出Debug版本和Release版本的不同目录.当然,通过宏,还可以区分更多版本.但是在指定目录时,不小心容易出错.

方法3: 
直接添加库文件到工程中.

就像你添加.h和.cpp文件一样,把lib文件添加到工程文件列表中去.

VS中,切换到”解决方案视图”—>选中要添加lib的工程–>点击右键–>”添加”–>”现有项”–>选择lib文件–>确定。

这个方法适用于工程的Debug版本和Release版本中都使用同一个lib库文件时.这样就省去了你方法一配置环境的繁琐，也省去了方法二中语句的可能性错误发生。

#### 添加dll

一般将dll拷贝到运行时目录即可，与调用者exe文件在同一目录。当然有其他方法添加环境变量PATH
> release版本和debug版本的区分，每种版本的设置都是独立的，要分别设置

### 显式连接

隐式链接虽然实现较简单，但除了必须的.dll文件外还需要DLL的.h文件和.lib文件，在那些只提供.dll文件的场合就无法使用，而只能采用显式链接的方式。这种方式通过调用API函数来完成对DLL的加载与卸载，能更加有效地使用内存，在编写大型应用程序时往往采用此方式。这种方法编程具体实现步骤如下：

1. 使用Windows API函数LoadLibrary或者MFC提供的AfxLoadLibrary将DLL模块映像到进程的内存空间，对DLL模块进行动态加载。
2. 使用GetProcAddress函数得到要调用DLL中的函数的指针。
3. 不用DLL时，用FreeLibrary函数或者AfxFreeLibrary函数从进程的地址空间显式卸载DLL。

使用LoadLibrary显式链接，那么在函数的参数中可以指定DLL文件的完整路径；如果不指定路径，或者进行隐式链接，将遵循下面的搜索顺序来定位搜索DLL：

包含EXE文件的目录  
工程目录  
Windows系统目录  
Windows目录  
列在Path环境变量中的一系列目录

## 静态库lib的使用

静态lib中，一个lib文件实际上是任意个obj文件的集合，obj文件是cpp文件编译生成的。静态库的.lib文件包含了链接库的所有信息（函数代码和接口信息）。所以我们在调用静态库.lib时，只需要包含头文件目录（../include. .h），以及附加库目录即可。因此，静态链接库的使用需要库的开发者提供生成库的.h头文件和.lib文件


工程使用lib方式：

1. 添加lib  
方法1：
直接用”项目右击”->”添加”–>”现有项”–>选择lib文件–>确定，通过这种方式将.lib加入工程  
方法2：
工程属性-> 配置属性->链接器->输入->附加依赖项中添加要使用的Lib库的名字；在工程属性-> 配置属性->链接器->常规->附加库目录中输入.lib文件所在路径（相对或绝对路径）

方法3：
在源代码中加入指令`#pragma comment(lib, "testLib.lib")`，也可以指定完整路径（绝对路径或相对路径）`#pragma comment(lib, “..\Debug\TestLib.lib”)`。可以通过宏`#if defined(_DEBUG)`来区分用release或debug版本的lib。另外如果不指定完整路径，也要像方法2一样添加附加库目录。

如果不在工程属性中添加附加lib库目录，也可以将静态里边库比如TestLib.lib拷贝到工程所在目录，或者拷贝到执行文件生成的目录，或者拷贝到系统Lib目录中。

2.  添加头文件

加入相应的头文件test.h。``#include "test.h"``

include file path可以为绝对路径，也可以为相对于工程所在目录的相对路径。

如果头文件比较多，可以在`项目->属性->配置属性->C/C++->常规->附加包含目录`中填入你的头文件所在目录，编译时会自动在此目录查找头文件。